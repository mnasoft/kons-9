(in-package :kons-9)

(defparameter *window-size* '(960 540))
(defparameter *current-mouse-pos-x* 0)
(defparameter *current-mouse-pos-y* 0)
(defparameter *current-mouse-modifier* nil)
(defparameter *ui-interactive-mode* nil)
(defparameter *current-highlighted-ui-item* nil)
(defparameter *current-choice-menu-and-pos* nil) ;nil or (menu x y)

(defparameter *scene-view* nil)

#|
;;;; app-view ==================================================================

(defclass-kons-9 app-view (ui-group)
  ((scene-view (make-instance 'scene-view))
   (outliner-view (make-instance 'ui-view))
   (inspector-view (make-instance 'ui-inspector :obj *scene*))
   (timeline-view (make-instance 'ui-button-item))))

(defmethod initialize-instance :after ((view app-view) &rest initargs)
  (declare (ignore initargs))
  (update-layout view)
  (ui-add-child view (scene-view view))
  (ui-add-child view (outliner-view view))
  (ui-add-child view (inspector-view view))
  (ui-add-child view (timeline-view view)))

(defmethod update-layout ((view app-view))
  (with-accessors ((w ui-w) (h ui-h))
      view
    (let ((x0 (* w .25))
          (y0 (* h .25))
          (x1 (* w .75))
          (y1 (* h .75))
          (x2 (* h .50)))
      (ui-set-rect (outliner-view view) 0 0 x0 h)
      (ui-set-rect (inspector-view view) x1 0 x0 h)
      (ui-set-rect (scene-view view) x0 0 x2 y1)
      (ui-set-rect (timeline-view view) x0 y1 x2 y0)))
  view)
|#

;;;; scene-view ================================================================

(defclass-kons-9 scene-view ()
  ((scene nil)
   (status-bar nil)
   (ui-contents (make-instance 'ui-group :layout :vertical :justification :right/bottom
                                         :draw-border? nil :padding 0 :spacing 10))
   (ui-contents-scroll 0)               ;offset in y
   (menu nil)
   (command-tables '())
   (mouse-binding nil)                  ;fn to call when control-mouse-drag
   (mouse-binding-string nil)
   ))

(defmethod initialize-instance :after ((view scene-view) &rest initargs)
  (declare (ignore initargs))
  (init-view-camera)
  (setf (status-bar view) (make-status-bar)))
;;  (push (app-command-table view) (command-tables view)))

(defun show-ui-content (view)
  (let ((contents (ui-contents *scene-view*)))
    (ui-add-child contents view)
    (update-layout contents)
    ;; scroll if going off bottom of view
    (let ((delta-y (- (+ (ui-y contents) (ui-h contents))
                      (- (second *window-size*) (ui-h (status-bar *scene-view*)) 20))))
      (when (> delta-y 0)
        (decf (ui-contents-scroll *scene-view*) delta-y)))
    (update-ui-content-position)))

(defun hide-ui-content (view)
  (let ((contents (ui-contents *scene-view*)))
    (ui-remove-child contents view)
    (update-layout contents)))

(defun update-ui-content-position ()
  (let ((view (ui-contents *scene-view*)))
  ;; (case location
  ;;   (:top-left
  ;;    (ui-set-position view 20 20))
  ;;   (:top-right
    (ui-set-position view
                     (- (first *window-size*) (ui-w view) 20)
                     (+ 20 (ui-contents-scroll *scene-view*)))))
    ;; (:bottom-left
    ;;  (ui-set-position view 20 (- (second *window-size*) (ui-h view) 20)))
    ;; (:bottom-right
    ;;  (ui-set-position view
    ;;                   (- (first *window-size*) (ui-w view) 20)
    ;;                   (- (second *window-size*) (ui-h view) 20)))))

(defun reposition-ui-content-after-delete ()
  (when (< (ui-contents-scroll *scene-view*) 0)
    (let* ((contents (ui-contents *scene-view*))
           (delta-y (- (+ (ui-y contents) (ui-h contents))
                       (- (second *window-size*) (ui-h (status-bar *scene-view*)) 20))))
      (when (< delta-y 0)
        (decf (ui-y contents) delta-y)
        (setf (ui-y contents) (min 20 (ui-y contents)))))))

(defun app-command-table (view)
  (let ((table (make-instance 'command-table :title "kons-9")))
    (ct-subtable :S "Scene" (scene-command-table view))
    (ct-subtable :E "Edit" (edit-command-table view))
    (ct-subtable :C "Create" (create-command-table view))
    (ct-subtable :I "Inspect" (inspect-command-table view))
    (ct-subtable :D "Display" (display-command-table view))
    (ct-entry    :M "Interactive Mode (ESC to exit)"
                 (hide-menu view)
                 (setf *ui-interactive-mode* (not *ui-interactive-mode*)))
    (ct-subtable :X "Context" (context-command-table))
    table))

(defun scene-command-table (view)
  (let ((table (make-instance 'command-table :title "Scene")))
    (ct-entry :N "New Scene" ;;; (clear-scene (scene view)) (ui-clear-children (ui-contents view)))
              (let ((scene (make-instance 'scene)))
                (setf *scene* scene)
                (setf (scene view) *scene*)
                (ui-clear-children (ui-contents view))
                (setf (ui-contents-scroll view) 0)))
;; TODO -- open and save need work
;;    (ct-entry :O "Open Scene" (hide-menu view) (ui-clear-children (ui-contents view)) (show-open-scene-dialog))
;;    (ct-entry :S "Save Scene" (hide-menu view) (show-save-scene-dialog))
    (ct-entry :E "Export OBJ File" (show-export-obj-scene-dialog))
    (ct-entry :U "Export USD File" (show-export-usd-scene-dialog))
    (ct-entry :I "Initialize Scene" (init-scene (scene view))) ;same as '[' key binding
    (ct-entry :Q "Quit Scene" (glfw:set-window-should-close))
    table))

(defun show-open-scene-dialog ()
  (show-ui-content
   (make-text-input-dialog-box "Open Scene File"
                               (lambda (str)
                                 (let ((scene (load-scene str)))
                                   (setf *scene* scene)
                                   (setf (scene *scene-view*) *scene*))))))

(defun show-save-scene-dialog ()
  (show-ui-content
   (make-text-input-dialog-box "Save Scene File"
                               (lambda (str)
                                 (save-scene (scene *scene-view*) str)))))

(defun show-export-obj-scene-dialog ()
  (show-ui-content
   (make-text-input-dialog-box "Export OBJ File"
                               (lambda (str)
                                 (export-obj (scene *scene-view*) str)))))

(defun show-export-usd-scene-dialog ()
  (show-ui-content
   (make-text-input-dialog-box "Export USD File"
                               (lambda (str)
                                 (export-usd (scene *scene-view*) str)))))

(defun edit-command-table (view)
  (let ((table (make-instance 'command-table :title "Edit")))
;;    (ct-entry :S "Select (TBD)")
    (ct-entry :backspace "Delete" (delete-selection (scene view)))
    ;; TODO -- handle selected motions -- activate/deactivate...
    (ct-entry :S "Show" (dolist (shape (selected-shapes (scene view))) (setf (is-visible? shape) t)))
    (ct-entry :H "Hide" (dolist (shape (selected-shapes (scene view))) (setf (is-visible? shape) nil)))
    ;; (ct-entry :D "Duplicate (TBD)")
    ;; (ct-entry :G "Group (TBD)")
    ;; (ct-entry :U "Ungroup (TBD)")
    ;; (ct-entry :F "Find (TBD)")
    table))

(defun create-command-table (view)
  (declare (ignore view))
  (let ((table (make-instance `command-table :title "Create")))
    (ct-subtable :C "Create Curve" (curve-command-table))
    (ct-subtable :P "Create Polyhedron" (polyhedron-command-table))
    table))

(defun curve-command-table ()
  (let ((table (make-instance `command-table :title "Create Curve")))
    (ct-make-shape :L "Line Curve" (make-line-curve (p! 0 0 0) (p! 2 2 2) 4))
    (ct-make-shape :R "Rectangle Curve" (make-rectangle-curve 2 1 4))
    (ct-make-shape :S "Square Curve" (make-square-curve 1.5))
    (ct-make-shape :C "Circle Curve" (make-circle-curve 2.0 16))
    (ct-make-shape :A "Arc Curve" (make-arc-curve 2.0 0 90 8))
    (ct-make-shape :N "Sine Curve" (make-sine-curve-curve 360 1 2 1 16))
    (ct-make-shape :P "Spiral Curve" (make-spiral-curve .2 2.0 -1.0 4 64))
    table))

(defun polyhedron-command-table ()
  (let ((table (make-instance `command-table :title "Create Polyhedron")))
    (ct-make-shape :T "Tetrahedron" (make-tetrahedron 2.0))
    (ct-make-shape :C "Cube" (make-cube 2.0))
    (ct-make-shape :O "Octahedron" (make-octahedron 2.0))
    (ct-make-shape :D "Dodecahedron" (make-dodecahedron 2.0))
    (ct-make-shape :I "Icosahedron" (make-icosahedron 2.0))
    (ct-make-shape :S "Sphere" (make-cube-sphere 4.0 3))
    table))

(defun inspect-command-table (view)
  (let ((table (make-instance `command-table :title "Inspect")))
    (ct-entry :R "Reset Camera" (init-view-camera) (3d-update-light-settings))
    (ct-entry :F "Frame Selection")
    (ct-entry :I "Inspector" (show-ui-content (make-ui-inspector (or (selection (scene view))
                                                                     (scene view)))))
    (ct-entry :S "Shapes" (show-ui-content (make-ui-outliner-viewer "Shapes" (shape-root (scene view)))))
    (ct-entry :M "Motions" (show-ui-content (make-ui-motion-outliner-viewer "Motions" (motion-root (scene view)))))
    table))

(defun display-command-table (view)
  (declare (ignore view))
  (let ((table (make-instance 'command-table :title "Display")))
    (ct-entry :grave-accent "Toggle Lighting" (setf *do-lighting?* (not *do-lighting?*)))
    (ct-entry :1 "Toggle Filled Display" (setf *display-filled?* (not *display-filled?*)))
    (ct-entry :2 "Toggle Wireframe Display" (setf *display-wireframe?* (not *display-wireframe?*)))
    (ct-entry :3 "Toggle Point Display" (setf *display-points?* (not *display-points?*)))
    (ct-entry :4 "Toggle Backface Culling" (setf *do-backface-cull?* (not *do-backface-cull?*)))
    (ct-entry :5 "Toggle Smooth Shading" (setf *do-smooth-shading?* (not *do-smooth-shading?*)))
    (ct-entry :6 "Toggle Ground Plane Display" (setf *display-ground-plane?* (not *display-ground-plane?*)))
    (ct-entry :7 "Toggle World Axes Display" (setf *display-axes?* (not *display-axes?*)))
    (ct-entry :8 "Set Bright Theme" (set-theme-bright))
    (ct-entry :9 "Set Dark Theme" (set-theme-dark))
    table))

(defun context-command-table ()
  (let ((table (make-instance 'command-table :title "Context" :is-dynamic? t)))
    table))

(defun transform-command-table ()
  (let ((table (make-instance `command-table :title "Transform")))
    (ct-subtable :T "Translate" (translate-command-table))
    (ct-subtable :R "Rotate" (rotate-command-table))
    (ct-subtable :S "Scale" (scale-command-table))
    table))

(defmacro mouse-transform-setup (help-str &rest action-exprs)
  `(progn
     (setf (mouse-binding-string *scene-view*)
           (strcat "Mouse [CTRL]: " ,help-str "."))
     (setf (mouse-binding *scene-view*)
           (lambda (scene dx dy)
             (declare (ignore dy))
             (dolist (shape (selected-shapes scene))
               ,@action-exprs)))))

(defun translate-command-table ()
  (let ((table (make-instance `command-table :title "Translate")))
    (ct-entry :X "Translate X" (mouse-transform-setup
                                "Translate X"
                                (translate-by shape (p! (* dx .01) 0 0))))
    (ct-entry :Y "Translate Y" (mouse-transform-setup
                                "Translate Y"
                                (translate-by shape (p! 0 (* dx .01) 0))))
    (ct-entry :Z "Translate Z" (mouse-transform-setup
                                "Translate Z"
                                (translate-by shape (p! 0 0 (* dx .01)))))
    table))

(defun rotate-command-table ()
  (let ((table (make-instance `command-table :title "Rotate")))
    (ct-entry :X "Rotate X" (mouse-transform-setup
                                "Rotate X"
                                (rotate-by shape (p! (* dx 1) 0 0))))
    (ct-entry :Y "Rotate Y" (mouse-transform-setup
                                "Rotate Y"
                                (rotate-by shape (p! 0 (* dx 1) 0))))
    (ct-entry :Z "Rotate Z" (mouse-transform-setup
                                "Rotate Z"
                                (rotate-by shape (p! 0 0 (* dx 1)))))
    table))

(defun scale-command-table ()
  (let ((table (make-instance `command-table :title "Scale")))
    (ct-entry :U "Scale Uniformly" (mouse-transform-setup
                                    "Scale Uniformly"
                                    (scale-by shape (p! (+ 1 (* dx .01)) (+ 1 (* dx .01)) (+ 1 (* dx .01))))))
    (ct-entry :X "Scale X" (mouse-transform-setup
                                "Scale X"
                                (scale-by shape (p! (+ 1 (* dx .01)) 1 1))))
    (ct-entry :Y "Scale Y" (mouse-transform-setup
                                "Scale Y"
                                (scale-by shape (p! 1 (+ 1 (* dx .01)) 1))))
    (ct-entry :Z "Scale Z" (mouse-transform-setup
                                "Scale Z"
                                (scale-by shape (p! 1 1 (+ 1 (* dx .01))))))
    table))


(defmethod draw-scene-view ((view scene-view))
  (3d-setup-buffer)
  (3d-setup-projection)
  (3d-update-light-settings)
  (when (scene view)
    (draw (scene view)))
  (3d-cleanup-render)
  (when *display-axes?*
    (draw-world-axes))
  (when *display-ground-plane?*
    (draw-ground-plane))

  ;; display ui layer

  (2d-setup-projection (first *window-size*) (second *window-size*))

  ;; draw scene ui
  (text-engine-begin-frame)
  (draw-scene-view-ui view)
  (text-engine-end-frame)

  ;; draw scene ui overlay (e.g. choice menus)
  (text-engine-begin-frame)
  (draw-scene-view-ui-overlay view)
  (text-engine-end-frame)

  (3d-flush-render))

(defmethod draw-scene-view-ui ((view scene-view))
  (draw-view (status-bar view) 0 0)
  (let ((menu (menu view)))
    (when (and menu (is-visible? menu))
      (when (not (eq (command-table menu) (car (command-tables view))))
        (make-popup-menu view)
        (setf (is-visible? (menu view)) t))
      (draw-view (menu view) 0 0)))
  (draw-view (ui-contents view) 0 0))

(defmethod draw-scene-view-ui-overlay ((view scene-view))
  (draw-view-overlay (ui-contents view) 0 0))

(defmethod make-popup-menu ((view scene-view))
  (when (command-tables view)
    (setf (menu view)
          (make-instance 'ui-popup-menu :ui-x 20 :ui-y 20 :command-table (car (command-tables view))))
    (create-contents (menu view))))

;;; respond to first click in window
;; (defmethod accepts-first-mouse ((self scene-view) event)
;;   (declare (ignore event))
;;   t)

(defmethod mouse-down ((self scene-view) event)
  ;; TODO -- do 3D selection
  )

;;; accept key events
;; (defmethod accepts-first-responder ((self scene-view))
;;   t)

(defmethod show-menu ((self scene-view))
  (setf (menu self) (make-popup-menu self))
  (setf (is-visible? (menu self)) t))

(defmethod hide-menu ((self scene-view))
  (setf (menu self) nil)
  (setf (command-tables self) (last (command-tables self)))) ;pop all but original table

;;; TODO -- register global key bindings: esc, space, tab, [, backspace, etc
(defmethod key-down ((self scene-view) key mod-keys)
  ;; (format t "key-down self: ~a, key: ~a mod-keys: ~a~%" self key mod-keys)
  ;; (finish-output)
  (cond ((and *current-choice-menu-and-pos* (eq :escape key)) ;escape closes any choice menu
         (setf (is-visible? (elt *current-choice-menu-and-pos* 0)) nil)
         (unregister-choice-menu))
        (*ui-keyboard-focus*  ;handle text box input, do this first as it overrides other bindings
         (cond
           ;; emacs bindings (just for fun)
           ((and (eq :f key) (member :control mod-keys))
            (do-arrow-input *ui-keyboard-focus* :right))
           ((and (eq :b key) (member :control mod-keys))
            (do-arrow-input *ui-keyboard-focus* :left))
           ((and (eq :a key) (member :control mod-keys))
            (do-arrow-input *ui-keyboard-focus* :up))
           ((and (eq :e key) (member :control mod-keys))
            (do-arrow-input *ui-keyboard-focus* :down))
           ((and (eq :d key) (member :control mod-keys))
            (do-delete-forward-input *ui-keyboard-focus*))
           ((and (eq :k key) (member :control mod-keys))
            (do-kill-line-input *ui-keyboard-focus*))
           ((and (eq :y key) (member :control mod-keys))
            (do-paste-input *ui-keyboard-focus* (glfw:get-clipboard-string)))
           ;; cut and paste
           ((and (eq :v key) (member :super mod-keys))
            (do-paste-input *ui-keyboard-focus* (glfw:get-clipboard-string)))
           ((and (eq :c key) (member :super mod-keys))
            (glfw:set-clipboard-string (do-copy-input *ui-keyboard-focus*)))
           ((and (eq :x key) (member :super mod-keys))
            (glfw:set-clipboard-string (do-cut-input *ui-keyboard-focus*)))
           ((and (eq :a key) (member :super mod-keys))
            (do-select-all *ui-keyboard-focus*))
           ;; backspace
           ((eq :backspace key)
            (do-backspace-input *ui-keyboard-focus* mod-keys))
           ;; arrow navigation
           ((member key '(:left :right :up :down))
            (do-arrow-input *ui-keyboard-focus* key))
           ))
        (*ui-interactive-mode*          ;interactive mode: send keyboard events to scene interactor
         (if (eq :escape key)           ;escape exits interactive mode
             (setf *ui-interactive-mode* nil)
             (update-scene-interactor (scene self) key mod-keys)))
        ((eq :space key)                ;play animation
         (update-scene (scene self))
         (update-scene-ui))
        ((eq :left-bracket key)         ;init scene
         (init-scene (scene self)))
        ((eq :backspace key)            ;delete selected items
         (delete-selection (scene self))
         (update-scene-ui))
        ((eq :tab key)                  ;hide/show main menu
         (cond ((and (menu self) (is-visible? (menu self))) ;menu visible
                (if (> (length (command-tables self)) 1)    ;submenu visible
                    (setf (command-tables self) (last (command-tables self))) ;go to main menu
                    (hide-menu self)))  ;hide menu
               (t
                (show-menu self))))
        ((eq :escape key)               ;hide all inspectors
         (ui-clear-children (ui-contents self))
         (setf (ui-contents-scroll self) 0))
        ((and (member :shift mod-keys) (eq :left key)) ;hide last inspector
         (ui-remove-last-child (ui-contents self))
         (update-scene-ui)
         (if (= 0 (length (children (ui-contents self))))
             (setf (ui-contents-scroll self) 0)
             (reposition-ui-content-after-delete)))
        ((eq :left key)                 ;go to previous menu
         (when (and (menu self) (is-visible? (menu self)) (> (length (command-tables self)) 1))
           (setf (command-tables self) (cdr (command-tables self)))))
        ((or (eq :up key) (eq :down key)) ;scroll inspectors
         (incf (ui-contents-scroll self) (if (eq :up key) -50 50))
         (update-ui-content-position))
        ((and (menu self) (is-visible? (menu self))) ;do menu selection
         (do-command (car (command-tables self)) key)
         (update-scene-ui))
        ((= (length (command-tables self)) 1) ;do menu selection for top menu even if hidden
         (when (do-command (car (command-tables self)) key)
           (show-menu self)))))

(defmethod key-up ((self scene-view) key)
  )

;;XXX This doesn't work on wayland. I think wayland expects clients
;; to draw the window decorations themselves
(defun update-window-title (window)
  (glfw:set-window-title (format nil "kons-9 | window ~A" *window-size*) window))

(glfw:def-key-callback key-callback (window key scancode action mod-keys)
  (declare (ignore scancode))
  ;; (format t "key-callback: w: ~a, k: ~a, sc: ~a, a: ~a, mk: ~a ~%"
  ;;         window key scancode action mod-keys)
  ;; (finish-output)
  (cond ;;((and (eq key :escape) (eq action :press))
         ;;(glfw:set-window-should-close))
        ((or (eq action :press) (eq action :repeat))
         (when *scene-view*
           (key-down *scene-view* key mod-keys)))
        ((eq action :release)
         (when *scene-view*
           (key-up *scene-view* key))))
  (update-window-title window))

(glfw:def-char-callback char-callback (window char)
  ;; (format t "char-callback: w: ~a, k: ~a~%" window char)
  ;; (finish-output)
  (when (and *scene-view* *ui-keyboard-focus*)
    (do-char-input *ui-keyboard-focus* char)))

(glfw:def-mouse-button-callback mouse-callback (window button action mod-keys)
  ;; (format t "mouse-btn-callback: w: ~a, b: ~a, a: ~a, mk: ~a ~%"
  ;;         window button action mod-keys)
  ;; (finish-output)
  (let ((pos (glfw:get-cursor-position window)))
    (setf *current-mouse-pos-x* (first pos))
    (setf *current-mouse-pos-y* (second pos))
    (setf *current-mouse-modifier* (and mod-keys (car mod-keys)))
    (cond ((eq action :press)
           (mouse-click (first pos) (second pos) button mod-keys)))))

(glfw:def-cursor-pos-callback cursor-position-callback (window x y)
  ;;  (format t "mouse x: ~a, y: ~a~%" x y)
  (let ((dx (- x *current-mouse-pos-x*))
        (dy (- y *current-mouse-pos-y*)))
    (setf *current-mouse-pos-x* x)
    (setf *current-mouse-pos-y* y)
    (let ((action (glfw:get-mouse-button :left window)))
      (cond ((eq action :press)
             (mouse-dragged x y dx dy))
            (t
             (mouse-moved x y dx dy))))))

(defun register-choice-menu (menu x y)
  (setf *current-choice-menu-and-pos* (list menu x y)))

(defun unregister-choice-menu ()
  (setf *current-choice-menu-and-pos* nil))

(defun highlight-ui-item-under-mouse (ui-view x y)
  (when *current-highlighted-ui-item*
    (setf (highlight? *current-highlighted-ui-item*) nil)
    (setf *current-highlighted-ui-item* nil))
  (let ((ui-item (if *current-choice-menu-and-pos* ;choice menu gets priority
                     (find-ui-at-point (elt *current-choice-menu-and-pos* 0)
                                       x y
                                       (elt *current-choice-menu-and-pos* 1)  ;menu global x
                                       (elt *current-choice-menu-and-pos* 2)) ;menu global y
                     (find-ui-at-point ui-view x y))))
    (if (and ui-item (is-active? ui-item))
        (progn
          (setf (highlight? ui-item) t)
          (when (not (eq ui-item *current-highlighted-ui-item*)) ;new highlighted item
            (setf *current-highlighted-ui-item* ui-item))
          ui-item)
        nil)))

(defun do-action-ui-item-under-mouse (ui-view x y button modifiers)
  (let ((ui-item (if *current-choice-menu-and-pos* ;choice menu gets priority
                     (find-ui-at-point (elt *current-choice-menu-and-pos* 0)
                                       x y
                                       (elt *current-choice-menu-and-pos* 1)  ;menu global x
                                       (elt *current-choice-menu-and-pos* 2)) ;menu global y
                     (find-ui-at-point ui-view x y))))
    (if (and ui-item (is-active? ui-item))
        (progn
          (do-action ui-item x y button modifiers)
          (update-scene-ui)
          ui-item)
      nil)))

(defun mouse-moved (x y dx dy)
  (declare (ignore dx dy))
  ;;  (format t "mouse-moved x: ~a, y: ~a~%" x y)
  ;; menu takes priority over other ui components in view -- assume no overlap
  (let ((menu (menu *scene-view*)))
    (if (and menu (is-visible? menu))
        (when (not (highlight-ui-item-under-mouse menu x y))
          (highlight-ui-item-under-mouse (ui-contents *scene-view*) x y))
        (highlight-ui-item-under-mouse (ui-contents *scene-view*) x y))))

(defun mouse-click (x y button modifiers)
  ;; clear keyboard focus
  (setf *ui-keyboard-focus* nil)
  ;; menu takes priority over other ui components in view -- assume no overlap
  (let ((menu (menu *scene-view*)))
    (if (and menu (is-visible? menu))
        (when (not (do-action-ui-item-under-mouse menu x y button modifiers))
          (do-action-ui-item-under-mouse (ui-contents *scene-view*) x y button modifiers))
        (do-action-ui-item-under-mouse (ui-contents *scene-view*) x y button modifiers))))

(defun mouse-dragged (x y dx dy)
;;  (format t "mouse-dragged dx: ~a, dy: ~a, mod: ~a~%" dx dy *current-mouse-modifier*)
  (if *current-highlighted-ui-item*
      (do-drag-action *current-highlighted-ui-item* x y dx dy)
      (do-3d-navigation x y dx dy)))

(defun do-3d-navigation (x y dx dy)
  (declare (ignore x y))
  (cond ((eq :control *current-mouse-modifier*) ;user-defined mouse binding
         (when (mouse-binding *scene-view*)
           (funcall (mouse-binding *scene-view*) (scene *scene-view*) dx dy)))
        ((eq :alt *current-mouse-modifier*)    ;default mouse scene navigation -- pan
         (if (>= (abs dx) (abs dy))
             (incf *cam-side-dist* (* 0.1 dx))
             (incf *cam-up-dist* (* -0.1 dy))))
        ((eq :shift *current-mouse-modifier*)  ;default mouse scene navigation -- in/out
         (incf *cam-fwd-dist* (* 0.1 dx)))
        (t                                     ;default mouse scene navigation -- orbit
         (incf *cam-x-rot* dy)
         (incf *cam-y-rot* dx))))

(defun update-gl-3d-viewport ()
  (let* ((w (first *window-size*))
         (h (second *window-size*)))
    ;;      (x0 (* w .25))
    ;;      (y0 (* h .25))
    ;;      (w0 (* w .50))
    ;;      (h0 (* h .75)))
    ;; (setf *viewport-aspect-ratio* (/ w0 h0))
    ;; (gl:viewport x0 y0 w0 h0)))
    (setf *viewport-aspect-ratio* (/ w h))
    ;; TODO -- figure out why this is half-size viewport on retina display
#-:darwin(gl:viewport 0 0 w h)
    ))

(defun window-resized (window w h)
  ;; (format t "window-resized: win: ~a, w: ~a, h: ~a ~%" window w h)
  ;; (finish-output)
  (unless (zerop h)
    (setf *window-size* (list w h))
    (update-clip-rect)
    (update-gl-3d-viewport)
    (draw-scene-view *scene-view*)      ; redraw while being resized
    (glfw:swap-buffers)
    (update-scene-ui)
    (update-status-bar (status-bar *scene-view*) :view-width w :view-height h)
    (update-window-title window)))

(glfw:def-window-position-callback window-position-callback (window x y)
  (declare (ignore window x y))
  (update-gl-3d-viewport))

(glfw:def-window-size-callback window-size-callback (window w h)
  ;; (format t "window-size-callback: win: ~a, w: ~a, h: ~a ~%" window w h)
  ;; (finish-output)
  (window-resized window w h))

(defun update-scene-ui ()
  (loop for view across (children (ui-contents *scene-view*))
        do (create-contents view))
  (update-layout (ui-contents *scene-view*))
  (update-ui-content-position))

(defun update-status-bar-for-scene ()
  (let* ((scene (scene *scene-view*))
         (status-bar (status-bar *scene-view*))
         (menu-str (format nil "TAB: hide menu. L-ARROW: previous menu."))
         (mouse-str "Mouse: orbit, [ALT] pan, [SHIFT] in/out. TAB: show/hide menu.")
         (mouse-binding-str (mouse-binding-string *scene-view*))
         (inspector-str (if (> (length (children (ui-contents *scene-view*))) 0)
                            "UP/DN-ARROW: scroll inspectors. ESC: close inspectors, SHIFT-L-ARROW: close last inspector."
                            ""))
         (secondary-str (if mouse-binding-str
                            mouse-binding-str
                            inspector-str)))
    (update-status-bar status-bar
                       :str0 (format nil "Current Frame: ~a [~a-~a]"
                                     (current-frame scene) (start-frame scene) (end-frame scene))
                       :str1 (let ((n-shapes (num-shapes scene))
                                   (n-motions (num-motions scene)))
                               (format nil "Scene: ~a shape~p, ~a motion~p"
                                       n-shapes n-shapes n-motions n-motions))
                       :str2 (format nil "Selection: ~a shape~p" (length (selection scene))  (length (selection scene)))
                       :str3 (format nil "Cursor: (~a, ~a)"
                                     (floor *current-mouse-pos-x*) (floor *current-mouse-pos-y*))
                       :str4 (cond (*ui-interactive-mode*
                                    "INTERACTIVE MODE ON")
                                   (*current-highlighted-ui-item*
                                    (help-string *current-highlighted-ui-item*))
                                   ((not (menu *scene-view*))
                                    (strcat mouse-str " " secondary-str))
                                   (t
                                    (strcat menu-str " " secondary-str))))
    (if *ui-interactive-mode*
        (setf (bg-color status-bar) (c! .2 1 .2 0.5))
        (setf (bg-color status-bar) (c! 1 1 1 0.5)))))

(defun update-clip-rect ()
  (setf *ui-clip-rect* (make-instance 'ui-rect
                                      :ui-x 0 :ui-y 0
                                      :ui-w (first *window-size*) :ui-h (second *window-size*))))

(defun show-window (scene &optional (command-table nil))
  ;; XXX TODO assert that this is running on the main thread.
  ;; Graphics calls on OS X must occur in the main thread
  ;; Normally this is called by run function in kernel/main.lisp

  (handler-bind ((error
                   (lambda (condition)
                     (trivial-backtrace:print-backtrace condition)
                     (return-from show-window))))
    (sb-int:with-float-traps-masked
        (:invalid
         :inexact
         :overflow
         :underflow
         :divide-by-zero)
      (glfw:with-init-window (:title "kons-9" :width (first *window-size*) :height (second *window-size*))
        ;; (let ((app-view (make-instance 'app-view)))
        ;;   (setf (scene (scene-view app-view)) scene)
        ;;   (setf *scene-view* (scene-view app-view))

        (let ((scene-view (make-instance 'scene-view :scene scene)))
          ;; assign top level command-table for view
          (push (or command-table (app-command-table scene-view))
                (command-tables scene-view))
          
          ;; Hack! Need to figure out how to tie a scene-view to a window
          ;; in glfw3. For now, just set the first scene-view created
          ;; as default and use that for event handling
          (setf *scene-view* scene-view)
          (update-clip-rect)

          ;; assume monitor scale is same in x and y, just use first value
          ;; also assume we are running on the "primary" monitor
          ;; use FLOOR due to bug encountered with user's 4K monitor setting of 1.1458334
          (setf (monitor-scale *drawing-settings*)
                (floor (first (glfw:get-monitor-content-scale (glfw:get-primary-monitor)))))
          (set-lines-thin)

          (setf %gl:*gl-get-proc-address* #'glfw:get-proc-address)
          (glfw:set-key-callback 'key-callback)
          (glfw:set-char-callback 'char-callback)
          (glfw:set-mouse-button-callback 'mouse-callback)
          (glfw:set-cursor-position-callback 'cursor-position-callback)
          (glfw:set-window-position-callback 'window-position-callback)
          (glfw:set-window-size-callback 'window-size-callback)
          (setf *window-size* (glfw:get-window-size))
          (update-clip-rect)
          ;;           (setf *viewport-aspect-ratio* (/ (first *window-size*) (second *window-size*)))
          (update-gl-3d-viewport)
          (update-window-title glfw:*window*)
          (update-status-bar (status-bar *scene-view*)
                             :view-width (first *window-size*) :view-height (second *window-size*))
          (initial-text-engine-setup)
          (loop until (glfw:window-should-close-p)
                do (when *ui-interactive-mode*          ;interactive mode do idle
                     (update-scene-interactor (scene *scene-view*) nil nil))
                do (draw-scene-view *scene-view*)
                do (update-status-bar-for-scene)
                do (glfw:swap-buffers)
                do (glfw:poll-events)))))))

;;; does not return a useful value
(defmacro with-clear-scene (&body body)
  `(progn
     (clear-scene (scene *scene-view*))
     ,@body
     (update-scene-ui)
     (setf (ui-contents-scroll *scene-view*) 0)
     ))


